{"meta":{"title":"aLong","subtitle":"一个人总是可以善待他毫不在意的人。--王尔德","description":null,"author":"aLong","url":"http://blog.51ai.vip","root":"/"},"pages":[{"title":"关于","date":"2019-03-29T04:30:18.000Z","updated":"2019-04-01T09:58:46.879Z","comments":true,"path":"about/index.html","permalink":"http://blog.51ai.vip/about/index.html","excerpt":"","text":"站点 小站记录信息，写写笔记。之前wordpress搭建的博客意外被黑。数据好在有备份，之后又经历vps被卖家停止，原因是他们不做这生意，他们上级把他们的客户封停了….。后来想想算了，放在GitHub上吧。 个人信息 aLong，QQ：604302709 Email：604302709@qq.com"},{"title":"","date":"2019-04-11T03:31:35.364Z","updated":"2019-04-11T03:31:35.216Z","comments":true,"path":"categories/index.html","permalink":"http://blog.51ai.vip/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-04-11T03:31:53.537Z","updated":"2019-04-11T03:31:53.390Z","comments":true,"path":"tags/index.html","permalink":"http://blog.51ai.vip/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"SwitchHosts管理编辑hosts工具","slug":"SwitchHosts管理编辑hosts工具","date":"2019-08-14T01:41:55.000Z","updated":"2019-08-14T02:11:56.702Z","comments":true,"path":"2019/08/14/SwitchHosts管理编辑hosts工具/","link":"","permalink":"http://blog.51ai.vip/2019/08/14/SwitchHosts管理编辑hosts工具/","excerpt":"","text":"管理Hosts工具 SwitchHosts地址: SwitchHosts 开发工程中,针对不同项目设置不同的域名. 办法很多,例如直接编辑hosts文件,通过环境工具提供的功能设置等. 现在要安利一款便捷实用的工具. SwitchHosts!! 为什么,首先这工具是多平台支持的,我们可以在不同系统中使用.如果之前是靠编辑hosts文件的花,那不同的hosts位置还需要记忆一下,当然这也算不了什么难事. 他的有点不在于能简单编辑hosts文件,也有之前的记录,还可以通过url来读取云端的hosts信息.导入导出功能等. 总之又可以偷懒了. 主界面: 我们可以编辑不同host 分组,使用时打开开关按钮即可使用.示例中使用的My hosts中的配置 配置界面: 支持中文,主题黑白两色.","categories":[{"name":"tools","slug":"tools","permalink":"http://blog.51ai.vip/categories/tools/"}],"tags":[{"name":"hosts","slug":"hosts","permalink":"http://blog.51ai.vip/tags/hosts/"}]},{"title":"VMware安装MacOS系统","slug":"VMware安装MacOS系统","date":"2019-08-12T03:29:38.000Z","updated":"2019-08-12T03:38:55.999Z","comments":true,"path":"2019/08/12/VMware安装MacOS系统/","link":"","permalink":"http://blog.51ai.vip/2019/08/12/VMware安装MacOS系统/","excerpt":"","text":"虚拟机安装 macOS准备工作: VM关闭进程,利用macOS Unlocker修改VM使其能安装macOS系统, 执行程序 win-install.cmd 使用管理员权限运行脚本. 准备好macOS镜象. 利用VM创建虚机,系统类型选择macOS,版本号选择与下载的镜象版本相同. 装系统: 启动虚拟机,并通过cdrom加载镜象. 首次安装需要先利用系统内硬盘工具格式化硬盘,之后利用安装工具进行系统安装. 异常问题: 开启虚拟机弹出错误:vcpu-0 错误. 修改虚机镜象文件.vmx 在smc.present = “TRUE”下面插入一行代码: smc.version = 0 不能正常登陆APPID 需要修改虚拟机,利用Chameleon Wizard 伪造设备信息. 保存 生成的信息 去修改镜象所在文件下的.vmx 修改 board-id.reflectHost = “TRUE” 为FALSE,并在下面插入需要的伪造设备信息例子: board-id = “Mac-94245B3640C91C81”hw.model.reflectHost = “FALSE”hw.model = “MacBook Pro”serialNumber.reflectHost = “FALSE”serialNumber = “C02JJ8B3DH2G”smbios.reflectHost = “FALSE” 这段信息中的board-id 与 serialNumber 不要与例子的相同.其他可以参考.最后保存,重启. 重启之后尝试是否可以登陆市场.","categories":[{"name":"note","slug":"note","permalink":"http://blog.51ai.vip/categories/note/"}],"tags":[{"name":"vm","slug":"vm","permalink":"http://blog.51ai.vip/tags/vm/"}]},{"title":"数据库迁移","slug":"Laravel5数据库迁移","date":"2019-07-26T06:30:25.000Z","updated":"2019-08-01T07:12:50.393Z","comments":true,"path":"2019/07/26/Laravel5数据库迁移/","link":"","permalink":"http://blog.51ai.vip/2019/07/26/Laravel5数据库迁移/","excerpt":"","text":"Laravel5 数据库迁移笔记 创建迁移文件 命令: make:migration 举例: php artisan make:migration create_users_table --create=users 生成位置: 项目/database/migrations/下 文件名已时间开头,后面是自己创建迁移文件名字. –creat 指定数据库中表的名字 编辑迁移文件 打开迁移文件:","categories":[],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://blog.51ai.vip/tags/Laravel/"}]},{"title":"Composer笔记","slug":"Composer笔记","date":"2019-07-15T09:24:45.000Z","updated":"2019-07-15T09:36:28.983Z","comments":true,"path":"2019/07/15/Composer笔记/","link":"","permalink":"http://blog.51ai.vip/2019/07/15/Composer笔记/","excerpt":"","text":"composer - laravel5创建laravel项目：conposer create-project laravel/laravel=5.8.* --prefer-dist ./XXX laravel=5.8.* 这里代表要部署5.8中最高版本 –prefer-dist 参数代表优先下载zip 安装vendor:composer install composer install --prefer-dist 更新：composer update composer版本更新：composer self-update 利用composer 创建laravel控制器：php artisan make:controller HomeController 会在http下 创建一Home的控制器 如果存在分目录情况，需要指定目录：php artisan make:controller Home/HomeController Laravel config:编写一些类的别名，controller中 use 简短的别名为目的。 位置：config/app 存在一数组 aliases 在里面添加 创建模型：创建一个user 的model php artisan make:model User 指定目录加入目录即可 获取项目路由：php artisan route:list composer在项目中安装三方库时候出现报错：执行命令： composer Install 返回错误： Your requirements could not be resolved to an installable set of packages. 解决： 使用 composer install --ignore-platform-reqs 命令设置忽略版本匹配然后再进行安装你所需要的composer包。","categories":[{"name":"note","slug":"note","permalink":"http://blog.51ai.vip/categories/note/"}],"tags":[{"name":"Composer","slug":"Composer","permalink":"http://blog.51ai.vip/tags/Composer/"}]},{"title":"无版权素材站点","slug":"无版权素材站点","date":"2019-06-27T01:58:04.000Z","updated":"2019-06-27T02:01:40.691Z","comments":true,"path":"2019/06/27/无版权素材站点/","link":"","permalink":"http://blog.51ai.vip/2019/06/27/无版权素材站点/","excerpt":"","text":"最近找素材收集一些站点无版权对于我们来说可以放心使用 列表如下： http://www.pexels.com/ http://www.gratisography.com/ https://visualhunt.com/ http://finda.photo http://cupcake.nilssonlee.se/ https://www.photock.jp/ http://pngimg.com/ http://www.designerspics.com http://kaboompics.com/ https://pixabay.com/ https://visualhunt.com/ http://finda.photo http://www.freemagebank.com/ https://stocksnap.io/ http://picjumbo.com/ http://stokpic.com/ https://cn.freeimages.com/ http://www.imcreator.com/free https://www.piqsels.com/zh https://magdeleine.co/browse/ https://colorhub.me/ https://picjumbo.com/ http://streetwill.co/ https://www.foodiesfeed.com/ http://www.peakpx.com/ http://www.polayoutu.com/collections https://negativespace.co/ https://freeforcommercialuse.net/ https://mmtstock.com/","categories":[{"name":"note","slug":"note","permalink":"http://blog.51ai.vip/categories/note/"}],"tags":[{"name":"素材","slug":"素材","permalink":"http://blog.51ai.vip/tags/素材/"}]},{"title":"shell","slug":"shell","date":"2019-06-17T09:42:21.000Z","updated":"2019-06-17T09:42:22.024Z","comments":true,"path":"2019/06/17/shell/","link":"","permalink":"http://blog.51ai.vip/2019/06/17/shell/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hexo笔记","slug":"Hexo笔记","date":"2019-06-04T02:46:48.000Z","updated":"2019-06-04T08:21:42.403Z","comments":true,"path":"2019/06/04/Hexo笔记/","link":"","permalink":"http://blog.51ai.vip/2019/06/04/Hexo笔记/","excerpt":"","text":"多tag文章中 多tag时,无法直接, 空格这种. 方式一: tags: [tag1,tag2] 方式二:123tags:- tag1- tag2","categories":[{"name":"note","slug":"note","permalink":"http://blog.51ai.vip/categories/note/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://blog.51ai.vip/tags/Hexo/"}]},{"title":"Python建立SocketSSL连接","slug":"Python建立SocketSSL连接","date":"2019-06-04T02:23:11.000Z","updated":"2019-07-16T01:35:54.922Z","comments":true,"path":"2019/06/04/Python建立SocketSSL连接/","link":"","permalink":"http://blog.51ai.vip/2019/06/04/Python建立SocketSSL连接/","excerpt":"","text":"Python Socket连接5月中旬遇到一个功能,需要利用Python建立Socket tcp连接,于设备通讯发送相关数据. 这块没接触,Python也是hello world水平. 赶紧恶补一下: Socket是网络编程的一个抽象概念。 通常我们用一个Socket表示“打开了一个网络链接”，打开一个Socket需要知道目标计算机的IP地址和端口号，再指定协议类型。 服务端我也不知道什么样,这里只记录客户端的相关. 这里我们得到一个文档说,需要建立socket SSL 连接,通过XML格式发送数据. 非ssl的socket:1234567import socket# 创建一个socket:s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)# 建立连接:s.connect(('192.168.1.230', 80)) SSL socket:端口是3344,ssl跳过验证,如果验证参数需要修改.123456789import socket s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) c = ssl.wrap_socket(s, cert_reqs=ssl.CERT_NONE) try: c.connect(('192.168.1.230', '3344'))except: return 2 这下与那台设备可以正常通讯了,后面实现具体功能就ok了.","categories":[{"name":"note","slug":"note","permalink":"http://blog.51ai.vip/categories/note/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://blog.51ai.vip/tags/Python/"},{"name":"Socket","slug":"Socket","permalink":"http://blog.51ai.vip/tags/Socket/"}]},{"title":"Ubutun16.04安装Python","slug":"Ubutun16-04安装Python","date":"2019-05-24T03:17:59.000Z","updated":"2019-05-24T05:36:44.658Z","comments":true,"path":"2019/05/24/Ubutun16-04安装Python/","link":"","permalink":"http://blog.51ai.vip/2019/05/24/Ubutun16-04安装Python/","excerpt":"","text":"目的安装python3.7.3安装pip 准备工作 系统内置python2.X,去除默认python的软链, sudo rm /usr/bin/python 安装一些软件包&amp;软件包保持最新状态. sudo apt-get update sudo apt-get install build-essential zlib1g-dev libncurses5-dev libgdbm-dev libnss3-dev libssl-dev libreadline-dev libffi-dev wget 安装Python通过编译安装python 默认我下载在home里, cd 下载新python文件, wget https://www.python.org/ftp/python/3.7.3/Python-3.7.3.tgz 解压文件, tar zxf Python-3.7.3.tgz 把这个文件拷贝到放置的位置. 这里我放到/usr/local/python mkdir -p /usr/local/python 进入这个目录, 执行 ./configure --enable-optimizations之后执行 sudo make -j 8 这里8根据设备cpu核心数来的,不知道你可以写1(手动滑稽) make之后 该 make install 嘛? NO! 是 sudo make altinstall 装完之后, 可以尝试 python –version 看看有没有, 如果没有或者版本不对.可能是准备里你没有删除 /usr/bin/python 或者这个不存在.需要手动添加一下,我这个是没有给我创建成功. sudo ln -s /usr/local/Python-3.7.3/python /usr/bin/python 这里版本是3.7.3版本的python已经好了,但我发现没有pip.那我只好装一下pip. 安装pip同样在home目录下载:curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py 下载完成后, 执行 python get-pip.py我遇到一个问题是: Command ‘lsb_release -a’ returned non-zero exit status 1查了一下,大概意思是lsb_release上的问题,这里python2.X用到的(Ubutun自带2.X),那我解决办法是干掉他 sudo rm -f /usr/bin/lsb_release 重新执行上面的命令,ok 已经安装上pip. 到此结束.","categories":[{"name":"note","slug":"note","permalink":"http://blog.51ai.vip/categories/note/"}],"tags":[{"name":"python","slug":"python","permalink":"http://blog.51ai.vip/tags/python/"}]},{"title":"Go学习笔记","slug":"Go学习笔记","date":"2019-05-15T03:05:52.000Z","updated":"2019-05-16T09:11:43.513Z","comments":true,"path":"2019/05/15/Go学习笔记/","link":"","permalink":"http://blog.51ai.vip/2019/05/15/Go学习笔记/","excerpt":"","text":"变量var 声明,支持类型判断. var name string string类型 name var s string 值初始化 var age = 20 age 类型自动推断 height := 165 简短声明(仅限函数使用) i,j,k := 3.8,true,100 声明一组变量 _, res := 123,321 _特殊变量名,赋予他的值会被丢弃 常量const 声明 const Pi = 3.14 声明一个常量Pi 1234const( apple = \"fruit\" banana ) banana 常量未定义初始化值会与apple值相同 数据类型boolean,整型,浮点型,字符串,错误 布尔 bool 初始化默认fasle 整型 int8,int16,int32,int64 (有符号) uint8(byte),uint16,uint32(rune),uint64 (无符号) uintptr byte,rune 与uint8,uint32别名 整形初始化默认值0 浮点型 float32,float64(默认浮点类型) complex64,complex128 float32,float64 初始化默认值0 字符串 双引号或,UTF8编码,\\转义 初始化默认值”” 修改需要转换类型为 rune或byte 操作后再转换 数组 长度非负整数 var arr = [10]int{1,2,3,4} 声明数组 切片 slice 切片默认初始化前nil s1 := make([]int,3,5) 声明切片 append() 尾部追加元素 切片长度是包含的元素个数, 容量是能存储的元素个数. Map kV结构集合 1234m := make(map[string]int) &#123; \"blue\": 1, \"red\": 2&#125; `delete(m,red)` 删除map中一项 `m[&quot;orange&quot;] = 3` 增加一项 `m[&quot;blue&quot;] = 4` 更新一项 range 遍历map,slice 123for i,v := range m &#123; fmt.Println(i,v)&#125; 函数1234func sub(x,y int) (z int) &#123; z = x - y return z&#125; 声明一个方法sub,参数x,y为int型, z返回参数 int型 函数无返回值可不声明,参数也可是函数. 可以传指针或传引用操作 ...int 表示传递变长的参数 defer 关键字 在函数最后执行动作的声明(延迟代码) 局部函数声明修改不影响全局,若全局有同名变量时,内部赋值会改变全局变量(非声明). 方法方法是特殊的函数,区别于方法有前置实例接收参数(receiver) 接口一种抽象的类型 1234type I interface &#123; Get() int Put(int)&#125; 声明时,不能有字段,不能自定义方法,只声明方法,不实习现. 12345//实现接口:func f(p I) &#123; fmt.Println(p.get()) p.Out(1)&#125; 接收一个接口类型作为参数 p实现了接口I,Get(),Put()方法.","categories":[{"name":"note","slug":"note","permalink":"http://blog.51ai.vip/categories/note/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://blog.51ai.vip/tags/Go/"}]},{"title":"redis笔记","slug":"redis笔记","date":"2019-04-25T09:12:52.000Z","updated":"2019-05-09T09:17:30.112Z","comments":true,"path":"2019/04/25/redis笔记/","link":"","permalink":"http://blog.51ai.vip/2019/04/25/redis笔记/","excerpt":"","text":"redis笔记单进程,默认16库, select N 切换库 flushdb 清空库 类型 string 字符串 list 列表 set 集合 sorted set有序集合 hash哈希 一个字符串支持512M 有序集合 每个元素会关联一个double类型分数。成员唯一，分数可以重复。 常用命令key：keys * exists key move key db 移除key 从库中 expire key 为key 设置过期时间 ttl key 查看多少秒过期，-1 永不过期， -2已过期 type key 查看类型 del key 删除 string：getrange key 0-N setrange key 0-N XXX 获取字符串范围内容， 设置范围内为XXX setex 设置生命值多少秒 setnx key 设置一个不存在的key mset mget msetnx list：lpush rpush lrange lpop rpop lindex llen lrem key 2 value 删除2个value ltrim key 0-N 截取并复制给key （其他的删除了） rpoplpush 弹出前面key的值 加入后面的key中 lset key index value 设置key中 index下标的值 linsert key before/afrer value1 value2 key中1值得前面后后面加入2值 set：sadd key value 添加到key集合 smembers key 查询集合 sismember key m 查询m是否在key集合中 scard key 集合ket的基数 spop key 随机移除一个元素并返回元素的值 srem key m 移除m从key的集合中 smove K1 K2 m 将k1的m一刀k2里 sinter key1 key2 交集 sunion key1 key2 并集 sdiff key1 key2 差集 hash：hset user name ali hset user age 33 设置user数据 hget user name 获取user.name hmset human name tom age 44 设置多数据 hmget human name age 获取多数据 hgetall human hdel human name 删除name hlen human 长度 hexists human age 是否存在 hkeys human 获取所有key hvals human 获取所有value hincrby hincrbyfloat hsetnx 不存在添加 zset：zadd key value：score 设置值的分数 zrange key zrangebyscore key min max （不包含 limit 升序 zrevrangebyscore 降序 zrem key value zcount key min max 范围内多少个 zscore key m 返回key 中m的分数值 zrevrange key start stop 降序展示 持久化：rdb aof rdb 快照方式定期生成临时文件，从临时文件替换上次持久化的文件。数据不是非常敏感。 dump.rdb dump.rdb 关机会清空文件，备份需要导出到另一台机器。 设备启动会去读取domp.rdb来恢复数据（文件名可以设置）。 关闭rdb 设置save为空 save命令 bgsave后台异步快照 备份到dump.rdb 优势： 适合大规模莫恢复，完整性和一致性要求不高。 劣势： 意外down 最后一次备份不到。内存被克隆一份，2倍的性能膨胀。 aof 日行形式记录每个写操作，将所有写指令记录。 appendonly yes 开启 注意flushdb all 这些东西也会记录操作。 同时存在两种备份，优先恢复aof文件，如果aof失败， 导入rbd备份数据。 aof文件损毁或异常时， 通过redis-check-aof程序修复后再恢复。 配置：appendfsync always/everysec/no 同步设置 rewrite： aof 采用文件追加方式，记录文件会越来越大，重写机智，aof 文件大小超过阈值时，会启动aof文件的内容压缩，只保留可恢复的最小指令。默认配置64M 事务： mulit 开启 语句 exec执行， discard 取消 语法错误时，全部没执行，如果设置错误，其他执行，错误的不执行。 监控 锁 乐观锁 悲观锁: 悲观锁，锁表。 乐观锁，行信息版本更新。 谁先提交谁成功。 wacth 监控字段，执行事务，如果监控字段未出现变化，事务执行成功。 复制机制： master 写 slave读 配置slave为主 slaveof 主库id 端口 info replication 查看信息 从机不能写数据 方式 1主机 多从机 主机down，从机待命。主机启动，从机继续同步主机。 从机端开，会变成master，除非配置文件规定。否则需要 slaveof 重新顶可以。 主机down后，如果从机某台执行 slaveof no one ，使当前从库变主库。 方式2 主机-&gt;从机-&gt;从机 相连 方式3 哨兵 监控主机是否down，down后根据投票选出从机转换主库。 配置中添加 sentinel.conf ，编写配置： sentinel monitor 主机配置 地址 端口 1 1标识投票 启动哨兵：redis-sentinel 哨兵配置","categories":[{"name":"redis","slug":"redis","permalink":"http://blog.51ai.vip/categories/redis/"}],"tags":[{"name":"redis,db","slug":"redis-db","permalink":"http://blog.51ai.vip/tags/redis-db/"}]},{"title":"gulp笔记","slug":"gulp笔记","date":"2019-04-22T10:08:54.000Z","updated":"2019-04-24T02:41:09.244Z","comments":true,"path":"2019/04/22/gulp笔记/","link":"","permalink":"http://blog.51ai.vip/2019/04/22/gulp笔记/","excerpt":"","text":"gulpgulp.js是一个前端构建工具。 安装 npm 安装全局gulp，npm install -g gulp。（如果没有梯子，最好安装下cnpm）cnpm 安装 npm install -g cnpm --registry=https://registry.npm.taobao.org安装完cnpm，下面所有npm操作替换cnpm 执行即可。 进入项目，初始化（npm init） 项目安装gulp，项目文件夹下，npm install --save-dev gulp。 (–save-dev 加入此项目依赖中，不需要可取消这个参数) 项目根创建gulpfile.js文件，文件内创建任务测试。 1234var gulp = require('gulp');gulp.task('default',function()&#123; console.log('hello world!');&#125;); 运行 gulp，可以看到默认执行，输出 hello world! 。测试成功。 gulp API上面运行 gulp 执行default ，这个是gulp API。 [文档](https://www.gulpjs.com.cn/docs/api/) gulp工作方式gulp.src 获取文件流,通过pipe方法导入到插件，插件处理的流通过pipe方法导入 gulp.dest中, gulp.dest 输出目标文件。 gulp srcgulp.src(globs[, options]) 输出（Emits）符合所提供的匹配模式（glob）或者匹配模式的数组（array of globs）的文件。 将返回一个 Vinyl files 的 stream 它可以被 piped 到别的插件中。 文档这意思看着有点费劲，理解为获取文件路径。gulp通过这个方法获取到处理的文件流。 参数： globs 文件匹配模式，匹配文件路径，文件名。 类型： string array options 额外可选参数 类型： object 额外参数需要看手册 gulp.destgulp.dest(path[, options]) 能被 pipe 进来，并且将会写文件。并且重新输出（emits）所有数据，因此你可以将它 pipe 到多个文件夹。如果某文件夹不存在，将会自动创建它。 理解为写文件，写入path路径文件。 参数： path 文件写入路径 类型：string function options 额外可选参数 类型：object gulp.taskgulp.task(name[, deps], fn) 定义一个使用 Orchestrator 实现的任务（task）。 用来定义任务，内部使用的是Orchestrator。 参数： name 任务名字 deps 是当前任务需要的其他任务，一个数组。依赖任务，先于此任务执行。 类型：array fn 该函数定义任务所要执行的一些操作，把任务要执行的代码写在里面。 gulp.watchgulp.watch(glob[, opts], tasks)gulp.watch(glob[, opts, cb]) 监视文件，并且可以在文件发生改动时候做一些事情。 参数： glob 文件匹配模式 类型 string array opts 可选配置 类型 object tasks 文件变动后执行的任务 类型 array cb 一个函数，文件发生变化时调用的函数。 类型 function Glob 匹配模式 (node-glob）参考语法 123456789101112131415161718192021222324252627282930匹配符 说明 * 匹配文件路径中的0个或多个字符，但不会匹配路径分割符， 除非分隔符出现在末尾 ** 匹配路径的0个会多个目录 及子目录 需要单独出现， 即他左右不能有其他的东西了如果出现在末尾，也能匹配文件 ？ 匹配文件路径中的一个字符（不能匹配路径分割符/） [...] 匹配方括号中 出现字符的任意一个，当方括号中第一个字符为^或!时， 则表示不匹配方括号中出现字符中的任意一个， 类似于js中正则表达式中的用法 !(pattern|pattern|pattern) 匹配任何与括号中给定的任意模式都不匹配 ？(pattern|pattern|pattern) 匹配括号中给定的任意模式0次或1次 +(pattern|pattern|pattern) 匹配括号中的至少一次 *(pattern|pattern|pattern) 匹配括号中给定的任意模式0次或多次 @(pattern|pattern|pattern) 匹配括号中 给定的任意模式一次 eg：glob 匹配 |能匹配 a.js,x.y,abc,abc/,但不能匹配a/b.js| |.* a.js,style.css,a.b,x.y //*.js 能匹配 a/b/c.js,x/y/z.js,不能匹配a/b.js,a/b/c/d.js ** 能匹配 abc,a/b.js,a/b/c.js,x/y/z,x/y/z/a.b,能用来匹配所有的目录和文件 a/**/z 能匹配 a/z,a/b/z,a/b/c/z,a/d/g/h/j/k/z a/**b/z 能匹配 a/b/z,a/sb/z,但不能匹配a/x/sb/z,因为只有单**单独出现才能匹配多级目录 ?.js 能匹配 a.js,b.js,c.js a?? 能匹配 a.b,abc,但不能匹配ab/,因为它不会匹配路径分隔符 [xyz].js 只能匹配 x.js,y.js,z.js,不会匹配xy.js,xyz.js等,整个中括号只代表一个字符 [^xyz].js 能匹配 a.js,b.js,c.js等,不能匹配x.js,y.js,z.js 多种匹配模式时，使用数组gulp.src([&#39;js/*.js&#39;,&#39;css/*.css&#39;,&#39;*.html&#39;]) 数组中可以用 ！ 排除(放在数组第一个无效)gulp.src([*.js,&#39;!b*.js&#39;]) 编写一个任务常用到压缩，写个压缩demo。目录，根目录下有两个文件夹，dist空文件，src目录,src/js文件夹2个文件，common.js,demo.js。任务目标，将js目录下的.js文件，压缩合并为new.min.js。之后将合并压缩的文件保存到dist/js/。 我们在初始化后的项目中，先安装所需插件，gulp-rename（重命名插件）,gulp-uglify（压缩js插件），gulp-concat（合并文件插件）。npm install gulp-rename gulp-uglify gulp-concat –save-dev 编辑gulpfile.js 123456789101112var gulp=require('gulp'); var rename= require('gulp-rename'); //引入插件var uglify= require('gulp-uglify');var concat= require('gulp-concat'); gulp.task('js', function()&#123; //创建名为 js的任务 return gulp.src('src/js/*.js') //读取文件流 .pipe(concat()) //合并 .pipe(uglify()) //压缩 .pipe(rename(&#123;suffix: '.min'&#125;)) //重命名 .pipe(gulp.dest('dist/js/')) //输出到指定路径 &#125;); 文件保存后，命令行执行任务： gulp js 。可以看到Finshed时间，去dist目录可以看到合并压缩的文件已在里面。 gulp插件 CSS压缩 gulp-minify-css Js压缩 gulp-uglify 重命名 gulp-rename 文件合并 gulp-concat 自动加载 gulp-load-plugins less编译 gulp-less sass编译 gulp-sass","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.51ai.vip/categories/前端/"}],"tags":[{"name":"gulp","slug":"gulp","permalink":"http://blog.51ai.vip/tags/gulp/"}]},{"title":"Centos7时间设置","slug":"Centos7时间设置","date":"2019-04-19T03:42:02.000Z","updated":"2019-04-19T03:54:26.520Z","comments":true,"path":"2019/04/19/Centos7时间设置/","link":"","permalink":"http://blog.51ai.vip/2019/04/19/Centos7时间设置/","excerpt":"","text":"Centos7时间相关查看时间datehwclock 硬件时间timedatectl 各时间状态 设置&amp;更新服务时间安装ntpdateyum install utp ntpdate 设置同步ntpdate cn.pool.ntp.org (time.windows.com) 地址看喜好 设置硬件时间hwclock –systohc 设置时区timedatectl set-timezone Asia/Shanghai （上海） timedatectl 很多设置，需要请查相关资料。","categories":[{"name":"note","slug":"note","permalink":"http://blog.51ai.vip/categories/note/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.51ai.vip/tags/Linux/"}]},{"title":"Centos7防火墙相关设置","slug":"Centos7防火墙相关设置","date":"2019-04-18T09:44:22.000Z","updated":"2019-04-18T10:06:06.083Z","comments":true,"path":"2019/04/18/Centos7防火墙相关设置/","link":"","permalink":"http://blog.51ai.vip/2019/04/18/Centos7防火墙相关设置/","excerpt":"","text":"Centos7与之前不太一样以前都是用iptables，公司服务器环境事7，凑巧不熟一台新服务。我为了测试，再本地虚机上装了一台。这里默认防火墙是 firewall，其实为了省事还是可以安装一个iptables的。这里学习一下firewall一些操作。 查看防火墙服务状态systemctl status firewalld ####查看f防火墙状态firewall-cmd --state 查看规则firewall-cmd --list-all ####停止&amp;开启防&amp;重启火墙systemctl stop firewalld.servicesystemctl start firewalld.servicesystemctl restart firewalld.service 关闭防火墙systemctl disable firewalld.service 重载防火墙firewall-cmd —reload 查询开放端口firewall-cmd --list-ports 开放一个端口 例如tcp 8010firewall-cmd –zone=public –add-port=80/tcp –permanent –zone #作用域–add-port=8010/tcp #添加端口，格式为：端口/通讯协议–permanent #永久生效，没有此参数重启后失效 查询某端口是否开放(8010)firewall-cmd --query-port=8010/tcp 移除端口规则firewall-cmd --permanent --remove-port=8010/tcp","categories":[{"name":"note","slug":"note","permalink":"http://blog.51ai.vip/categories/note/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.51ai.vip/tags/Linux/"}]},{"title":"Centos7启动等级设置","slug":"Centos7启动等级设置","date":"2019-04-15T08:55:19.000Z","updated":"2019-04-15T09:02:12.157Z","comments":true,"path":"2019/04/15/Centos7启动等级设置/","link":"","permalink":"http://blog.51ai.vip/2019/04/15/Centos7启动等级设置/","excerpt":"","text":"Centos7启动级别启动级别分为7个：0 - 系统停机状态1 - 单用户工作状态2 - 多用户状态（没有NFS）3 - 多用户状态（有NFS）4 - 系统未使用，留给用户5 - 图形界面6 - 系统正常关闭并重新启动 切换启动级别之前一直都是在种端中输入指令 init3 切换启动级别。设置永久启动3级别， vi /etc/inittab 把init3设置默认即可。 centos7 设置出现不同runlevels被targets所取代，即CentOS7采用加载target的方式来替代之前的启动级别。multi-user.target = init3graphical.target = init5我们日常实用图形窗口init5，我们不需要图形，可以切换到init3等启动级别上。systemctl set-default multi-user.target 设置为init3systemctl set-default graphical.target 设置为init5","categories":[{"name":"note","slug":"note","permalink":"http://blog.51ai.vip/categories/note/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.51ai.vip/tags/Linux/"}]},{"title":"Docker常用命令","slug":"Docker常用命令","date":"2019-04-11T07:09:19.000Z","updated":"2019-04-11T08:28:34.775Z","comments":true,"path":"2019/04/11/Docker常用命令/","link":"","permalink":"http://blog.51ai.vip/2019/04/11/Docker常用命令/","excerpt":"","text":"Docker常用命令说常用不如说自己用到的命令。 容器相关学习了一下docker，基础常用命令记录下。 ####docker run/新建并启动容器这个run其实包含两个不走，先执行新建容器(docker create),接着启动容器(docker start)。敲两个是不是有点麻烦吧。 docker run xx [COMMAND] 例子 docker run -it ubuntu:14.04 /bin/bash 这里希望启动一个基于 ubuntu 14.04镜像 来创建一个容器，-t选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上，-i则让容器的标准输入保持打开。更多的命令选项可以通过man docker-run命令来查看。之后命令还有一项，启动一个bash终端。 这条命令涉及到很多知识了。-参数 常用 -i -d -t -p， -d 是否在后台运行，-p 映射到本地主机端口。剩下的看手册来补下。 docker create &amp;&amp; docker start &amp;&amp; docker stop创建，启动，停止。有一个容易停止了，可以用 docker start XX容器 启动。 XX 可以是容器的ID，也可以是name。 docker rm删除一个容器（最好先把这个容器停止了再删除）。-f 可以强制删除。-v 删除与容器关联的卷（如果刚学习还真不知道什么是卷）。 docker attach进入容器，如果开启了一个 -d 后台启动容器。 我们怎么进去看看？ docker attach XX容器这个命令我学习时候用过，感觉有时候不太好使。命令执行完卡那不动。 docker exec可以在容器内直接执行任意命令。docker exec -it xx /bin/bash 这可以进入xx镜像，并打开bash。 相比这个比上面的attach 好多了。 docker ps列出启动中的容器， docker ps -a 列出所有镜像。 ###仓库相关 docker images列出本地镜像文件 docker rmi删除本地镜像文件 docker seach xxx在docker hub查询xxx 镜像 docker pull想不想git？ docker pull xx 可以下载xx镜像到本地。 （还能联想到 push 吧？ commit ？ 这些吧） docker login登陆docker hub docker push推送本地镜像到docker hub上。 数据相关-v在容器内创建数据卷 docker run -d -v /test ubuntu 在此镜像下创建一个test数据卷也可以挂在主机目录为数据卷 docker run -d -v /usr/local/src:/opt/test ubuntu 将本地的/usr/lcoal/src 挂载到此镜象的 /opt/test 作为数据卷。 在本机修改，容器内可以看到。这里可以增加参数来控制读写，默认读写。 volumes-from数据卷容器容器与容器间的数据挂在参数。例如有个容器为 files ，通过另一个 test来挂在files。 docker run -it --volumes-from files --name test ubuntu--name 是为后者容器起名。这个名字叫test 挂在了files 容器的数据。 端口映射，容器互联-p &amp;&amp; -Pdocker run -itd -p 8080:80 --name web nginx:1.15 本机8080端口映射到容器80.-p 需要自己分配端口 -P Docker会随机映射一个49000~49900的端口 docker port查看映射端口配置 link--link参数可以让容器之间安全地进行交互 基本上了解到的命令吧，后续根据搭建环境以及使用中来丰富其他的命令和参数。","categories":[{"name":"note","slug":"note","permalink":"http://blog.51ai.vip/categories/note/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://blog.51ai.vip/tags/docker/"}]},{"title":"Ubutun下安装Docker","slug":"Ubutun下安装Docker","date":"2019-04-04T06:57:16.000Z","updated":"2019-04-11T03:15:46.867Z","comments":true,"path":"2019/04/04/Ubutun下安装Docker/","link":"","permalink":"http://blog.51ai.vip/2019/04/04/Ubutun下安装Docker/","excerpt":"","text":"Docker简介 一个能够把开发的应用程序自动部署到容器的开源引擎三大概念：镜像（Image）容器（Container）仓库（Repository） 具体信息请参考官方。官方概述（养成看文档习惯） 安装环境Ubuntu 16.04 LTS Docker安装根据官方doc安装。官方doc1.如果你之前装过，命令卸载。sudo apt-get remove docker docker-engine docker.io containerd runc 2.更新包索引apt-get update 3.安装包以允许apt通过HTTPS使用存储库:sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg-agent \\ software-properties-common（斜线换行，一条命令） 4.添加Docker的官方GPG密钥:curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -sudo apt-key fingerprint 0EBFCD88 5.使用以下命令设置稳定存储库。要添加 夜间或测试存储库，请在下面的命令中的单词后添加单词nightly或test（或两者）stable。$ sudo add-apt-repository \\ &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) \\ stable&quot; (lsb_release -cs子命令返回Ubuntu发行版的名称) 6.安装最新版本的Docker CE和containerd，或者转到下一步安装特定版本： sudo apt-get install docker-ce docker-ce-cli containerd.io 7.运行hello-world 映像验证是否正确安装了Docker CE: sudo docker run hello-world (执行之后，返回docker的信息) 至此，安装过程是结束了。","categories":[{"name":"note","slug":"note","permalink":"http://blog.51ai.vip/categories/note/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://blog.51ai.vip/tags/Docker/"}]},{"title":"hexo博客安装与配置","slug":"hexo博客安装与配置","date":"2019-04-01T09:59:31.000Z","updated":"2019-04-11T03:15:33.791Z","comments":true,"path":"2019/04/01/hexo博客安装与配置/","link":"","permalink":"http://blog.51ai.vip/2019/04/01/hexo博客安装与配置/","excerpt":"","text":"wordpress 之后wordpress 使用很方便，但是折腾几次之后。由于一次意外，导致管理者把我的vps被停掉。虽然有些文章还是保留了。但是这次之后感觉自己还是找一个稳妥的家。连接hexo搭建的博客之后，打算自己来折腾一下。 记录笔记环境在windows上写笔记，环境目前是windows下操作。linux，mac系统中需要注意一些细节吧。存在提不到情况，先做好出现问题考虑自行排查。 准备看下hexo的安装提示。 hexo 需要Node.js 和 Git 。 安装 Node.js官网: 官网widows，mac，linux 都有对应的安装方法。根据自己的环境来安装。 安装 Git官网: 官网根据自己环境安装。 安装Hexo通过npm来安装 Hexo。命令: npm install -g hexo-cli什么鬼，通过这个命令发现没有实现正常安装。理由，我们在天朝。解决方式： 替换国内npm源。命令: npm install -g cnpm --registry=https://registry.npm.taobao.org请注意不同系统在操作此命令时，需要一些设置。linux 如果使用下面命令需要自建软链。 cnpm ln -s /yourdir/bin/cnpm /usr/local/npm下一步用cnpm 来安装 Hexo： cnpm install hexo-cli -g验证hexo 是否安装： hexo v 会列出版本信息。 下面使用Hexo来创建blog： 创建项目文件夹。这里开始通过git bash来使用命令行操作。 进入项目文件夹，初始化。 hexo init （这里也可以，通过 hexo init 你的项目文件夹名 结果一样）这里会看到目录有相关文件了。具体这些文件，看下 手册 是什么意思。这时候其实已经是一个博客站点了。 命令 hexo g , hexo s 得到信息：Hexo is running at http：//lcoalhost:4000` 注意4000端口需要未被占用。 访问地址就可以看到初始化的站点了。 （不喜欢默认主题可以修改主题） 写文章写文章需要先创建文档，这个文档默认生成在_post 文件夹下。 命令 hexo new testdoc 得到信息： Created:···path/testdoc.md 文档的位置，需要编辑这个文档来写文章（Markdown文档）。文档写好保存之后。命令 hexo g , hexo s 之后我们访问之 localhost:4000 就能看到自己的新文章了。 推送到Git仓库，在线访问。首先需要一个 GitHub ，注册账号。创建一个与账户名一样的库， 用户名.github.io , 之后在项目文件夹中，编辑 _config.yml 配置文件。 1234deploy: type: git repo: https://github.com/用户名/用户名.github.io.git (我相信你能知道这个地址在哪里) branch: master 之前写过testdoc.md 这个文件。提交到git库上，命令： hexo d , 提交是，会弹出账号密码让你输入。接着得到提示： Deploy done: git。 这里我们就提交到库上了。 （账号密码提交比较麻烦，可以通过配置公钥来解决）这里如果出现错误 Deployer not found：git ，需要安装一下。 命令 npm install hexo-deployer-git --save这时候我们可以通过 用户名.github.io.git 这个地址访问到博客了。（不喜欢这个地址，可以通过域名来绑定） 主题更换默认的主题让我们觉得太不个性化了。还没有能力自己操刀编辑，怎么办？ 建议先看下文档.了解一下,培养看文档习惯. 可以使用别人的主题，官网提供 提供一些，也可以通过网上其他人的推荐来使用自己喜欢的主题。例如在官网地址上看到有一个名字是 Next(很多人有这个,或基于此主题修改). 点击可以语言并且访问.地址 , 我们需要克隆到自己项目下 themes 文件下. 你可以下载zip到自己项目下解压,不过有些麻烦也不够B格.我们使用git操作. 打开gitbash, 进入到自己项目下/themes 命令 git clone https://github.com/theme-next/hexo-theme-next.git . 执行完后,themes 下会有这个文件. 使用next 主题, 需要在 _config.yml 上面设置主题. theme: next 配置主题为next 之后通过命令 hexo g, hexo s. 两个命令后, 登陆localshot:4000 查看一下. 嗯,已经替换成功了. 目前只是替换了主题,主题也是需要配置的,我们需要在 _config.yml 配置菜单等一些参数. 主题相关修改参数配置是需要在 项目/themes/languages/{language}.yml具体配置希望你看下每个主题的README,或者文档来学习着自己修改. 还要涉及到页面的问题,我们之前 hexo new xx文章 ,都是默认_post文件夹下, 如果我们要定义归档,友链,等页面.也是通过new 命令来实现的. 例如: 建立 tags页面 hexo new page tags之后你会看到 项目下/source/ 会出现tags 文件夹,进入里面会有一个index.md .这个文件就是你需要的tags 页面. 域名我们觉得github 这个url不太喜欢,并且也很长.可以配置自己的域名.首先我们需要一个自己的域名,通过万网什么的来购买一个.我是通过阿里云上万网购买的一个域名.这里不详细来说明域名的购买. 万网控制台里面,有域名的功能(例如阿里云,登陆后,控制台-&gt;域名-&gt;点击域名-&gt;域名解析). 在github，xxx.github.io 点击 settingsCustom domain 这里填写你的域名，save。 此处注意：你配置完后，会看到库中存在一个文件，CNANE文件。如果你再次提交新文档，会发现你的配置域名无法访问了！原因：你本地文件没有这个CNAME，通过hexo d 方式 更新库文件后，CNAME没了。通过配置域名后，把这个文件下载到本地项目中，位置请注意：项目/source 下。不然hexo d 不会提交到库中。 如果不搞定这个，那你每次hexo d 之后，都要改一次custom domain。（我想谁也不会每次都这么操作）到这里基本上你这台电脑上，发布你的博客。更新，推送到github都没有问题。还有一个问题就是那么如果我换一台电脑怎么办？ 通过分支来完善博客工作中使用版本控制器，很方便管理项目代码和文件。那么我们这个hexo 博客也需要这种方式来吧本地的hexo 博客项目推送到线上。如果过本地电脑出故障，或者更换电脑等情况下。我们依然可以通过clone到本地，进行发布博客。 克隆博客gitbash clone一份自己的博客(省略命令), 删除克隆后出.git 这个文件外其他文件。把之前本地初始化项目中的文件都复制到此项目中。 新建分支 git branch hexo, git checkout hexo. 两条命令,新建分支,切换至hexo 分支. 在新分支中，提交我们刚才复制过来的文件。 git add --all 提交文件并push到远程。 git commit -m &quot;mybolg files&quot;, git push origin hexo 推送带云端。 这下完成了，不用担心换电脑。换电脑后，clone一下，继续可以发布。ps：git你需要自己装。之后我们一直再这个 hexo 分支就好啦。每次hexo d 之后记得把新文件提交到hexo分支。 add commit push 三步骤不能忘。 配置公钥之前没提到这个，是因为我怕忘记密码，每次都手输入密码。也不是每个人都喜欢我这么操作。那可以选择配置公钥来解决提交时的认证。 gitbash ssh-keygen 生成密钥，注意看信息密钥提示位置。 打开生成目录下的 id_res.pub 这个是公钥。打开复制里面的数据，复制。 需要粘贴到github settings-&gt;SSH and GPG keys 里面。 测试一下配置 gitbash ssh -T git@github.com 得到信息 You’ve successfully authenticated, but GitHub does not provide shell access. 配置正常。 改完这里还不可以，需要配置项目hexo配置文件了，还记得是哪个文件嘛？（ _config.yml）之前我们用的是https，现在我们需要用ssh地址提交了。4.修改 _config.yml 这段配置的 repo地址，看下之前参数和现在参数。 12345deploy: type: git #repo: https://github.com/chenweil/chenweil.github.io.git # https repo: git@github.com:chenweil/chenweil.github.io.git # ssh branch: master 到这里我们已经配置好，我们下次写完文章是 hexo d 不会让你输入密码了。真的不用输入密码了吗? 你可能会遇到问题,怎么还需要认证?(因为我这环境出现了问题)看下错误 :git push origin hexofatal: HttpRequestException encountered.如果你现者句话,那么需要你更新一下Windows的git凭证管理器.管理器地址 到此基本的配置已经完成，文中只是简单的描述了基础工作。再哪方面出现问题需要通过文档和网络来查询问题。第一次接触此框架，还是好好看文档。你通过网络查询的很多结果存在一些问题。例如版本不同，环境不同等。最好的方法还是自己来分析，处理。养成好习惯，戒心浮气躁，坚持自己来解决问题。","categories":[{"name":"note","slug":"note","permalink":"http://blog.51ai.vip/categories/note/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://blog.51ai.vip/tags/hexo/"}]}]}